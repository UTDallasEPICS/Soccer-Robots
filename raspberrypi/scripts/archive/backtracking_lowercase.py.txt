ALIGN_ERROR = 5 # Degrees
DIST_ERROR = 20 # pixels

# WASD as a one-hot encoded binary
MOVE_FORWARD = 0b1000
MOVE_BACKWARD = 0b0010
TURN_RIGHT = 0b0001
TURN_LEFT = 0b0100 

# Determining Quadrant
QUAD_ONE = 1
QUAD_TWO = 2
QUAD_THREE = 3
QUAD_FOUR = 4

# Determining Axis Cases
AXIS_XP = 5
AXIS_YP = 6
AXIS_XN = 7
AXIS_YN = 8

# Importing math for trig calculation
import math as math

# determinig the local quadrant to position
def determine_quadrant(xdiff, ydiff):

    # Determine if car is on axis
    if(xdiff == 0):
        if(ydiff > 0):
            return AXIS_YP
        elif(ydiff < 0):
            return AXIS_YN
    elif(ydiff == 0):
        if(xdiff > 0):
            return AXIS_XP
        elif(xdiff < 0):
            return AXIS_XN
    
    # Determine Quadrant
    if(xdiff > 0 and ydiff > 0):
        return QUAD_ONE
    elif(xdiff < 0 and ydiff > 0):
        return QUAD_TWO
    elif(xdiff < 0 and ydiff < 0):
        return QUAD_THREE
    elif(xdiff > 0 and ydiff < 0):
        return QUAD_FOUR

# Get the universal angle between point and car position
def get_xtheta(xdiff, ydiff):
    if (xdiff == 0):
        return 90
    return math.degrees(math.atan(abs(ydiff)/abs(xdiff)))

# Get distance from car to position
def get_dist(xdiff, ydiff):
    return math.sqrt(xdiff ** 2 + ydiff ** 2)

# Determine next motion of the car
def get_direction(xpos, ypos, rot, xdest, ydest):
    # localize coordinates around position
    xdiff = xpos - xdest 
    ydiff = ydest - ypos

    # Calculate the quadrant in localized coordinates
    region = determine_quadrant(xdiff, ydiff)

    # Get localized angle
    thetax = get_xtheta(xdiff, ydiff)
    
    # Initialize theta variables
    thetacar = 0 # Adjusted rotation of AprilTag system utilized thetax and quadrant
    thetadiff = 0 # The difference between the current rotation of the car and the thetacar
    dist = get_dist(xdiff, ydiff) # Getting the distance of the thing


    # Setting theta car to adjust to AprilTag System
    match region:
        case 1: # QUAD_ONE
            thetacar = 270 - thetax
        case 2: # QUAD_TWO
            thetacar = 90 + thetax
        case 3: # QUAD_THREE
            thetacar = 90 - thetax
        case 4: # QUAD_FOUR
            thetacar = 270 + thetax
        case 5: # AXIS_XP
            thetacar = 270
        case 6: # AXIS_YP
            thetacar = 180
        case 7: # AXIS_XN
            thetacar = 90
        case 8: # AXIS_YN
            thetacar = 0
        case _:
            print("huh")

    thetadiff = rot - thetacar

    # print(f"x: {thetax}, car: {thetacar}, diff: {thetadiff}")

    # If robot is close enough to the position return done
    if(dist < DIST_ERROR):
        # print("We made it outta da hood")
        return -1

    # if the angle of the car is not aligned with the position, turn accordingly
    if(abs(thetadiff) > ALIGN_ERROR):
        if(thetadiff > 0): # +theta means turn left (counter clockwise from top)
            return TURN_LEFT
        elif(thetadiff <= 0): # -theta means turn right (clockwise from top)
            return TURN_RIGHT
    else: # If aligned move forward
       if(dist > 0):   
        return MOVE_FORWARD

